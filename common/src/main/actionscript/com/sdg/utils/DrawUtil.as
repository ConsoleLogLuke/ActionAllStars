package com.sdg.utils{		import flash.display.BitmapData;	import flash.display.Graphics;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	    public class DrawUtil	{		public static function drawGrid(graphics:Graphics, cols:uint, rows:uint, colW:Number = 1, rowH:Number = 1, matrix:Matrix = null):void		{			if (matrix == null) matrix = new Matrix();			else matrix = matrix.clone();						matrix.scale(colW, rowH);						var startPoint:Point = new Point(matrix.tx, matrix.ty);			var endPoint:Point = new Point(matrix.a * cols + matrix.tx, matrix.b * cols + matrix.ty);			var repeatOffset:Point = new Point(matrix.c, matrix.d);						drawParallelLines(graphics, rows + 1, startPoint, endPoint, repeatOffset);						endPoint.x = matrix.c * rows + matrix.tx, endPoint.y = matrix.d * rows + matrix.ty;			repeatOffset.x = matrix.a, repeatOffset.y = matrix.b;						drawParallelLines(graphics, cols + 1, startPoint, endPoint, repeatOffset);		}				public static function drawParallelLines(graphics:Graphics, numLines:uint, startPoint:Point, endPoint:Point, repeatOffset:Point):void		{			var ox:Number = 0, oy:Number = 0;			var i:int = -1;						while (++i < numLines)			{				graphics.moveTo(startPoint.x + ox, startPoint.y + oy);				graphics.lineTo(endPoint.x + ox, endPoint.y + oy);				ox += repeatOffset.x, oy += repeatOffset.y;			}		}				public static function drawPolygon(graphics:Graphics, vertices:Array, matrix:Matrix = null):void		{			drawLines(graphics, vertices.concat(vertices[0]), matrix);		}				public static function drawLines(graphics:Graphics, points:Array, matrix:Matrix = null):void		{			var i:int = 0;			var l:int = points.length;						if (matrix)			{				graphics.moveTo(					matrix.a * points[i].x + matrix.c * points[i].y + matrix.tx,					matrix.b * points[i].x + matrix.d * points[i].y + matrix.ty);							while (++i < l)				{					graphics.lineTo(						matrix.a * points[i].x + matrix.c * points[i].y + matrix.tx,						matrix.b * points[i].x + matrix.d * points[i].y + matrix.ty);				}			}			else			{				graphics.moveTo(points[i].x, points[i].y);				while (++i < l) graphics.lineTo(points[i].x, points[i].y);			}		}				public static function drawRect(graphics:Graphics, x:Number, y:Number, w:Number, h:Number, matrix:Matrix = null):void		{			var startPoint:Point = new Point(x, y);			drawLines(graphics, [startPoint, new Point(x + w, y), new Point(x + w, y + h), new Point(x, y + h), startPoint], matrix);		}				public static function fillRect(graphics:Graphics, color:uint, alpha:Number, x:Number, y:Number, w:Number, h:Number):void		{			graphics.beginFill(color, alpha);			graphics.drawRect(x, y, w, h);			graphics.endFill();		}				public static function fillBitmapRect(graphics:Graphics, bitmap:BitmapData, x:Number, y:Number, w:Number, h:Number, matrix:Matrix = null, repeat:Boolean = true, smooth:Boolean = false):void		{			graphics.beginBitmapFill(bitmap, matrix, repeat, smooth);			graphics.drawRect(x, y, w, h);			graphics.endFill();		}    }}