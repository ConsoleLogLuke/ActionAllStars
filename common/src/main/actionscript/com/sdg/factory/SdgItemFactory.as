package com.sdg.factory{	import com.sdg.model.Avatar;	import com.sdg.model.InventoryItem;	import com.sdg.model.ItemType;	import com.sdg.model.ModelLocator;	import com.sdg.model.PetItem;	import com.sdg.model.RoomLayerType;	import com.sdg.model.SdgItem;	import com.sdg.model.SdgItemUtil;	import com.sdg.model.Team;	import com.sdg.net.Environment;	import com.sdg.utils.ObjectUtil;	    public class SdgItemFactory extends AbstractXMLObjectFactory implements IXMLObjectFactory	{		public function getInstanceKey():String		{			return SdgItemUtil.getXMLKey(xml);		}				public function createInstance():Object		{			var itemClass:Class = SdgItemUtil.getXMLClass(xml.name(), xml.itId);			var item:SdgItem = SdgItem(new itemClass());						updateInstance(item);						return item;		}				public function updateInstance(instance:Object):void		{			var item:SdgItem = SdgItem(instance);						updateSdgItem(item);						if (item is Avatar)			{				updateAvatar(Avatar(item));			}			else if (item is InventoryItem)			{				updateInventoryItem(InventoryItem(item));			}						item.updateCount++;		}				//--------------------------------------------------------------------------		//		//  Update methods		//		//--------------------------------------------------------------------------				protected function updateSdgItem(item:SdgItem):void		{			item.avatarId = xml.aId;			item.spriteTemplateId = xml.stId;			item.animationSetIds = ObjectUtil.enumToArray(xml.asId);			item.name = xml.n;			item.thumbnailUrl = Environment.getAssetUrl() + xml.tUrl;			item.assetType = xml.assetType;			item.layerType = xml.lt.length() ? xml.lt : RoomLayerType.FLOOR;			item.numLayers = xml.nl.length() ? xml.nl : 1;						// Optional Properties.			if (xml.x.length())	item.x = xml.x;			if (xml.y.length()) item.y = xml.y;			if (xml.orientation.length()) item.orientation = xml.orientation;		}				protected function updateAvatar(avatar:Avatar):void		{			avatar.userId = xml.uId;			avatar.gender = xml.g;			avatar.points = xml.xp;			avatar.level = xml.l;			avatar.currency = xml.t;			avatar.privateRoom = xml.pr;			avatar.membershipStatus = xml.ms;			avatar.newsletterOptionStatus = xml.newsletterOption;			avatar.chatModeStatus = xml.cm;			//avatar.isPlaying = xml.isPlaying.length() > 0 ? xml.isPlaying == "true" : false;			if (xml.subLevelId && xml.subLevelId > 0) avatar.subLevel = xml.subLevelId;			avatar.xpGamer = xml.xga;			avatar.xpGuru = xml.xgu;			avatar.xpCollector = xml.xc;			avatar.homeTurfValue = xml.tv;			avatar.joinDate = new Date(Number(xml.joinDate));			avatar.isLegacy = (xml.isLegacy && xml.isLegacy == 1);			avatar.approved = xml.appr;			avatar.badgeCount = (xml.nb) ? xml.nb : 0;						// pet logic.			var leashedPetInfo:String = xml.lp;			if(leashedPetInfo != "")			{				var leashedInfo:Array = leashedPetInfo.split("~");				avatar.leashedPetInventoryId = leashedInfo[0];				avatar.leashedPetItemId = leashedInfo[1];			}						// Parse team ids.			var encodedTeams:String = xml.favteam;			var teams:Array = encodedTeams.split('~');			for each (var encodedTeam:String in teams)			{				if (encodedTeam == "") continue;								var teamValues:Array = encodedTeam.split("`");				var teamId:uint = teamValues[0];				var leagueId:uint = teamValues[1];				if (avatar.getFavoriteTeamId(leagueId) != teamId)				{					avatar.setFavoriteTeam(new Team(teamId), leagueId);					if (teamValues[2] == 1) avatar.favoriteLeagueId = leagueId;				}			}						if (xml.hasOwnProperty("badge")) avatar.equippedBadge = xml.badge;						// do we need to populate the apparel list?			if (ModelLocator.getInstance().avatar.userId != avatar.userId && xml.cl != undefined)			{				avatar.removeAllApparel();				var items:Array = String(xml.cl).split(";");				for each (var item:String in items)				{					var ids:Array = item.split(",");					if (ids.length != 2)						continue;										// create an InventoryItem from our ids					var inventoryItem:InventoryItem = new InventoryItem();					inventoryItem.itemId = ids[0];					inventoryItem.itemTypeId = ids[1];					var contextId:String = avatar.gender == 1 ? "101" : "103";					inventoryItem.previewUrl = Environment.getApplicationUrl() + "/test/inventoryPreview?itemId=" + inventoryItem.itemId + "&contextId=" + contextId;					inventoryItem.previewUrlAlt = Environment.getApplicationUrl() + "/test/inventoryPreview?itemId=" + inventoryItem.itemId + "&contextId=" + contextId + "&layerId=9010";					inventoryItem.thumbnailUrl = Environment.getApplicationUrl() + "/test/inventoryThumbnail?itemId=" + inventoryItem.itemId;					inventoryItem.itemSetId = xml.isId != undefined ? xml.isId : 0;										// add it to the avatar's apparel list					avatar.setApparel(inventoryItem);				}			}						if (xml.v.length()) avatar.version = xml.v;			if (xml.sId.length()) avatar.statusId = xml.sId;			if (xml.warned.length()) avatar.warned = xml.warned != "0";			if (xml.banned.length()) avatar.banned = xml.banned != "0";		}				protected function updateInventoryItem(item:InventoryItem):void		{			item.itemId = xml.iId;			item.itemTypeId = xml.itId;			item.inventoryItemId = xml.Id;			item.roomId = xml.rId;			item.name = xml.n;			item.description = xml.des;			item.previewUrl = Environment.getAssetUrl() + xml.pUrl;			item.themeId = xml.TurfThemeId;			item.layoutId = xml.layoutId;			item.turfValue = xml.HomeTurfValue;						// Add all attributes not just two arbitrary ones.			// -Molly			var attributeList:XMLList = xml.children();			for each(var i:XML in attributeList)			{				item.attributes[i.name()] = i.toString();			}						//item.attributes.gameId = xml.gameId;			//item.attributes.destination = xml.destination;						item.itemValueType = xml.dif;						// Parse out abstarct click handlers.			var clickHandlerString:String = xml.abstractClickHandlers;			var clickHandlerIds:Array = clickHandlerString.split('|');			item.abstractClickHandlerIds = clickHandlerIds;						// custom attributes			item.walkSpeedPercent = xml.walkSpeedPercent.length() ? xml.walkSpeedPercent : 0;			item.effectDurationSeconds = xml.effectDurationSecond.length() ? xml.effectDurationSecond : 0;			item.cooldownSeconds = xml.cooldownSeconds.length() ? xml.cooldownSeconds : 0;			item.charges = xml.charges.length() ? xml.charges : -1;			item.levelRequirement = xml.levelRequirement.length() ? xml.levelRequirement : 0;			item.itemSetId = xml.itemSetId.length() ? xml.itemSetId : 0;						// Call item type specific updates.			switch (item.itemTypeId)			{				case ItemType.PETS:					updatePetItem(PetItem(item));					break;			}		}				private function updatePetItem(pet:PetItem):void		{			// Parse happiness and energy values from xml.			var encodedHappiness:String = xml.hap;			var happinessValues:Array = encodedHappiness.split('~');			var happinessLevel:Number = int(happinessValues[0]) / 100;			var happinessTimeStamp:Number = int(happinessValues[1]);			happinessTimeStamp *= 1000;			var encodedEnergy:String = xml.enrg;			var energyValues:Array = encodedEnergy.split('~');			var energyLevel:Number = int(energyValues[0]) / 100;			var energyTimeStamp:Number = int(energyValues[1]);			energyTimeStamp *= 1000;			var createdDateFromServer:Number = Number(xml.crDate);						pet.setHappiness(happinessLevel, happinessTimeStamp);			pet.setEnergy(energyLevel, energyTimeStamp);			pet.isLeashed = (xml.leash == '1');			pet.isFollowingOwner = (xml.fm == '1');			if (createdDateFromServer > 0) pet.createdTime = createdDateFromServer * 1000;		}    }}