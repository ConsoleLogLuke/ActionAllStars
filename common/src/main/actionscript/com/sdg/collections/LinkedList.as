package com.sdg.collections{	import com.sdg.collections.LinkedListItem;	import com.sdg.collections.ICollection;	import com.sdg.collections.IIterator;	import flash.errors.IllegalOperationError;	import flash.events.EventDispatcher;		public class LinkedList extends EventDispatcher implements ICollection	{			private var _head:LinkedListItem;		private var _tail:LinkedListItem;				/**		 * Returns the number of items in the list.		 */		public function get size():uint		{			var count:int = 0;			var node:LinkedListItem = _head;						while (node) count++;						return count;		}			/**		 * Returns whether the list contains any items.		 */		public function get isEmpty():Boolean		{			return _head == null;		}				public function LinkedList(source:Array = null)		{			if (source)			{				for (var i:int = 0; i < source.length; i++)					addTail(source[i]);			}		}			/**		 * Adds the value to the end of the list and returns the added linked list item.		 */		public function addTail(value:*):LinkedListItem		{			var item:LinkedListItem = new LinkedListItem(value);						if (_tail) _tail.next = item;			if (!_head) _head = item;						_tail = item;						return item;		}			/**		 * Adds the value to the front of the list and returns the added linked list item.		 */		public function addHead(value:*):LinkedListItem		{			var item:LinkedListItem = new LinkedListItem(value);						if (_head) item.next = _head;			if (!_tail) _tail = item;						_head = item;						return item;		}			/**		 * Adds the value after the specified item and returns the added linked list item.		 */		public function addAfter(item:LinkedListItem, value:*):LinkedListItem		{			var newItem:LinkedListItem = new LinkedListItem(value);					newItem.next = item.next;			item.next = newItem;					if (item == _tail) _tail = newItem;					return newItem;		}				/**		 * Adds the value before the specified item and returns the added linked list item.		 */		public function addBefore(item:LinkedListItem, value:*):LinkedListItem		{			var newItem:LinkedListItem = new LinkedListItem(value);			var prev:LinkedListItem = getItemBefore(item);					prev.next = newItem;				newItem.next = item;					if (item == _head) _head = newItem;					return newItem;		}				/**		 * Returns whether the value exists.		 */		public function contains(value:*):Boolean		{			var item:LinkedListItem = _head;					while (item)			{				if (item.data == value) return true;				item = item.next;			}					return false;		}				/**		 * Returns the value at the end of the list.		 */		public function getTail():*		{			return _tail ? _tail.data : null;		}			/**		 * Returns the value at the front of the list.		 */		public function getHead():*		{			return _head ? _head.data : null;		}			/**		 * Returns the item at the end of the list.		 */		public function getTailItem():LinkedListItem		{			return _tail;		}			/**		 * Returns the item at the front of the list.		 */		public function getHeadItem():LinkedListItem		{			return _head;		}				/**		 * Returns the value of the item after the target.		 */		public function getAfter(target:LinkedListItem):*		{			if (!target.next) throw new ArgumentError("No item exists after the 'target' [" + target + "]");			return target.next.data;		}				/**		 * Returns the value of the item before the target.		 */		public function getBefore(target:LinkedListItem):*		{			var item:LinkedListItem = getItemBefore(target);						if (!item) throw new ArgumentError("No item exists before the 'target' [" + target + "]");			return item.data;		}			/**		 * Returns the item that wraps the specified value.		 */		public function getItemContaining(value:*):LinkedListItem		{			var item:LinkedListItem = _head;					while (item)			{				if (item.data == value) return item;				item = item.next;			}						throw new ArgumentError("No item exists for the specified 'value' [" + value + "]");		}				/**		 * Returns the item before the specified item.		 */		public function getItemBefore(target:LinkedListItem):LinkedListItem		{			var item:LinkedListItem = _head;					while (item)			{				var next:LinkedListItem = item.next;							if (next == target)					return item;				else					item = next;			}						return null;		}				/**		 * Removes the item at the end of the list and returns the value.		 */		public function removeTail():*		{			if (_tail == null) throw new IllegalOperationError("No items exist in this list.");			return _removeItem(_tail, getItemBefore(_tail));		}			/**		 * Removes the item at the front of the list and returns the value.		 */		public function removeHead():*		{			if (_head == null) throw new IllegalOperationError("No items exist in this list.");			return _removeItem(_head, null);		}			/**		 * Removes the item after the specified item from the list and returns the value.		 */		public function removeItemAfter(item:LinkedListItem):*		{			if (!item.next) throw new ArgumentError("No item exists after the 'item' [" + item + "].");			return _removeItem(item.next, item);		}			/**		 * Removes the item after the specified item from the list and returns the value.		 */		public function removeItemBefore(item:LinkedListItem):*		{			var prev:LinkedListItem = getItemBefore(item);						if (!prev) throw new ArgumentError("No item exists before the 'item' [" + item + "].");			return _removeItem(prev, getItemBefore(prev));		}			/**		 * Removes the specified item from the list and returns the value.		 */		public function removeItem(item:LinkedListItem):*		{			return _removeItem(item, getItemBefore(item));		}				/**		 * Removes the specified value from the list.		 */		public function remove(value:*):void		{			var item:LinkedListItem = getItemContaining(value);			_removeItem(item, getItemBefore(item));		}			/**		 * Unlinks all items in the list.		 */		public function removeAll():void		{			var item:LinkedListItem = _head;			var next:LinkedListItem;					while (item)			{				next = item.next;				item.next = null;				item = next;			}					_head = _tail = null;		}			/**		 * Returns an array of the items in the list.		 */		public function toArray():Array		{			var a:Array = [];			var item:LinkedListItem = _head;					while (item) {				a.push(item.data);				item = item.next;			}					return a;		}			/**		 * Returns an iterator for the list.		 */		public function getIterator():IIterator		{			return new LinkedListIterator(this);		}				/**		 * Removal helper method.		 */		private function _removeItem(item:LinkedListItem, prev:LinkedListItem):*		{			var next:LinkedListItem = item.next;						if (prev) prev.next = next;			item.next = null;					if (item == _head) _head = next;			if (item == _tail) _tail = prev;						return item.data;		}	}}import com.sdg.collections.LinkedListItem;import com.sdg.collections.LinkedList;import com.sdg.collections.IIterator;import flash.errors.IllegalOperationError;class LinkedListIterator implements IIterator{		private var _currentItem:LinkedListItem;	private var _list:LinkedList;		public function get location():Object	{		return _currentItem.next == _list.getHeadItem() ? _currentItem : null;	}		public function LinkedListIterator(list:LinkedList)	{		_list = list;		reset();	}	/**	 * Resets the iteration index;	 */	public function reset():void	{		_currentItem = new LinkedListItem(null);		_currentItem.next = _list.getHeadItem();	}	/**	 * Returns whether there remains an item to iterate over.	 */	public function hasNext():Boolean	{		return _currentItem.next != null;	}	/**	 * Returns the next item.	 */	public function next():*	{		if (!_currentItem.next) throw new IllegalOperationError("No item exists at the next location.");				_currentItem = _currentItem.next;		return _currentItem.data;	}	/**	 * Removes and returns the current item.	 */	public function remove():*	{		var data:*;				if (_currentItem == _list.getHeadItem())		{			data = _list.removeHead();			reset();		}		else		{			_currentItem = _list.getItemBefore(_currentItem);						if (!_currentItem) throw new IllegalOperationError("The current location is invalid.");						data = _list.removeItemAfter(_currentItem);		}				return data;	}		/**	 * Removes and returns the next item.	 */	public function removeNext():*	{		if (!_currentItem.next) throw new IllegalOperationError("No item exists at the next location.");				return _list.removeItemAfter(_currentItem);	}}