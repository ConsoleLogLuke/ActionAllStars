package com.sdg.collections{	import com.sdg.collections.iterators.Array2Iterator;		import flash.events.EventDispatcher;		public class Array2 extends EventDispatcher implements ICollection	{		protected var _height:int;		protected var _width:int;		protected var _size:int;		protected var _data:Array;				public function get width():uint		{			return _width;		}				public function set width(value:uint):void		{			setSize(value, _height);		}				public function get height():uint		{			return _height;		}				public function set height(value:uint):void		{			setSize(_width, value);		}				public function get isEmpty():Boolean		{			return _size < 1;		}				public function get size():uint		{			return _size;		}				public function Array2(width:uint = 0, height:uint = 0, source:Array = null)		{			reset(width, height, source);		}				public function reset(width:uint = 0, height:uint = 0, source:Array = null):void		{			_width = width;			_height = height;			_size = width * height;						if (source)			{				_data = source.slice();				_data.length = _size;			}			else _data = new Array(_size);		}		public function contains(value:*):Boolean		{			return _data.indexOf(value) > -1;		}				public function get(x:uint, y:uint):*		{			if (x < _width) return _data[y * _width + x];						return null;		}				public function getByIndex(index:uint):*		{			return _data[index];		}				public function getColumn(x:uint):Array		{				var a:Array = [];						if (x < _width)			{				var l:Number = _size - _width + x + 1;								while (x < l)				{					a.push(_data[x]);					x += _width;				}			}						return a;		}				public function getRow(y:uint):Array		{			var index:int = y * _width;						return _data.slice(index, index + _width);		}				public function getRect(x:int, y:int, w:uint, h:uint):Array		{			var a:Array = [];						if (x + w > _width) w = _width - x;			if (x < 0) w += x, x = 0;			if (y + h > _height) h = _height - y;			if (y < 0) h += y, y = 0;						var l:int = y + h;						while (y < l)			{				var index:int = y * _width + x;				a = a.concat(_data.slice(index, index + w));				y++;			}						return a;		}				public function fillAll(value:*):void		{			var i:int = _size;			while (--i > -1) _data[i] = value;		}				public function removeAll():void		{			_data = new Array(_size);		}				public function set(x:uint, y:uint, value:*):void		{			var index:int = x + y * _width;			if (index < _size) _data[index] = value;		}				public function setRect(x:uint, y:uint, w:uint, h:uint, value:*):void		{			if (x + w > _width) w = _width - x;			if (x < 0) w += x, x = 0;			if (y + h > _height) h = _height - y;			if (y < 0) h += y, y = 0;						var yl:int = y + h;			var xl:int = x + w;						for (y; y < yl; y++)			{				for (var ix:int = x; ix < xl; ix++)				{					_data[ix + y * _width] = value;				}			}		}				public function setByIndex(index:uint, value:*):void		{			_data[index] = value;		}		public function setAll(items:Array):void		{			_data = items.slice();			if (_data.length > _size) _data.length = _size;		}				public function setSize(width:uint, height:uint):void		{			var temp:Array = _data.slice();						_size = height * width;			_data = new Array(_size);						var minx:int = Math.min(width, _width);			var miny:int = Math.min(height, _height);						var x:int, y:int;						for (y = 0; y < miny; y++)			{				for (x = 0; x < minx; x++)					_data[y * width + x] = temp[y * _width + x];			}						_width = width;			_height = height;		}				public function getIterator():IIterator		{			return new Array2Iterator(this);		}		public function toArray():Array		{			return _data.slice();		}	}}