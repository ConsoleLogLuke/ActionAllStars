package com.sdg.task{	import com.sdg.collections.LinkedList;	import com.sdg.collections.IIterator;	import com.sdg.events.TaskEvent;	import com.sdg.task.ITask;	import com.sdg.task.ITaskContainer;	import flash.events.EventDispatcher;		public class TaskSequence extends EventDispatcher implements ITaskContainer	{		private var _tasks:LinkedList;		private var _currentTask:ITask;		private var _iter:IIterator;		private var _isRunning:Boolean = false;				public function get currentTask():ITask		{			return _currentTask;		}				public function get isRunning():Boolean		{			return _isRunning;		}				public function get numTasks():int		{			return _tasks.size;		}			public function TaskSequence(source:Array = null)		{			_tasks = new LinkedList(source);			_iter = _tasks.getIterator();		}		public function addTask(task:ITask):void		{			_tasks.addTail(task);		}				public function addTaskAfter(target:ITask, task:ITask):void		{			_tasks.addAfter(_tasks.getItemContaining(target), task);		}				public function addTaskBefore(target:ITask, task:ITask):void		{			_tasks.addBefore(_tasks.getItemContaining(target), task);		}				public function getTaskBefore(target:ITask):ITask		{			return _tasks.getBefore(_tasks.getItemContaining(target));		}				public function getTaskAfter(target:ITask):ITask		{			return _tasks.getAfter(_tasks.getItemContaining(target));		}				public function getAllTasks():Array		{			return _tasks.toArray();		}				public function removeTask(task:ITask):void		{			if (_isRunning && task == _currentTask)				throw new Error("Cannot remove the currently running 'task' " + task + '.');							_iter.remove();		}			public function removeAllTasks():void		{			if (_isRunning) throw new Error("Cannot remove all tasks while running.");					_iter.reset();						while (_iter.hasNext())				removeTaskListeners(_iter.removeNext());		}				public function reset():void		{			interrupt();			_iter.reset();		}				public function start():void		{			if (_isRunning) return;						_isRunning = true;			dispatchEvent(new TaskEvent(TaskEvent.START));			startNextTask();		}				public function interrupt():void		{			if (!_isRunning) return;			if (_currentTask) _currentTask.interrupt();		}		private function startNextTask():void		{			if (_iter.hasNext())			{				_currentTask = _iter.next();				_currentTask.addEventListener(TaskEvent.COMPLETE, onTaskComplete);				_currentTask.addEventListener(TaskEvent.INTERRUPT, onTaskInterrupt);				_currentTask.start();			}			else			{				_currentTask = null;				_isRunning = false;				dispatchEvent(new TaskEvent(TaskEvent.COMPLETE));			}		}			private function onTaskComplete(event:TaskEvent):void		{			removeTaskListeners(_currentTask);			startNextTask();		}				private function onTaskInterrupt(event:TaskEvent):void		{			_isRunning = false;			removeTaskListeners(_currentTask);			dispatchEvent(new TaskEvent(TaskEvent.INTERRUPT));		}				private function removeTaskListeners(task:ITask):void		{			task.removeEventListener(TaskEvent.COMPLETE, onTaskComplete);			task.removeEventListener(TaskEvent.INTERRUPT, onTaskInterrupt);		}	}}