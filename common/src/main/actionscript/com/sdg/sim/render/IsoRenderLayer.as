package com.sdg.sim.render{	import com.sdg.collections.QuickList;	import com.sdg.display.render.*;	import com.sdg.geom.*;	import com.sdg.sim.core.SimData;	import com.sdg.sim.core.SimEntity;		import flash.geom.*;		/**	 * The IsoRenderLayer class provides positioning and sorting	 * of each contained RenderObject.	 */	public class IsoRenderLayer extends RenderLayer	{		public static const DEPTH_PARTITION_FLAG:int = 0x08;				protected var partitionList:QuickList = new QuickList();				/**		 * Constructor. 		 * 		 * @param width The width of the layer.		 * @param height The height of the layer.		 * @param matrix The matrix that transforms the positioning of each display.		 */		public function IsoRenderLayer(width:Number = 0, height:Number = 0, matrix:Matrix = null, solid:Boolean = false)		{			super(width, height, matrix, solid);		}				override public function addItem(item:RenderObject):void		{			if (!(item is SimRenderObject))				throw new ArgumentError("Argument 'item' " + item + " must be an instance of SimRenderObject.");						super.addItem(item);		}				/**		 * Positions and sets the depth of each display.		 */		override public function render():void		{			var i:int = -1;			var l:int = renderList.length;			var rdata:SimRenderData;			var sdata:SimData;			var aabb:AABB;						partitionList.length = 0;						while (++i < l)			{				rdata = renderList[i];				sdata = rdata.simData;								var entity:SimEntity = rdata.entity;				//if (entity == null) continue;								aabb = rdata.aabb = entity.getAABB();								// Update depth.				rdata.depth = ((101 * (aabb.yMax + 1) + 100 * (aabb.xMax + 1)) * 4) >> 0;								if ((rdata.flags & RenderData.RENDER_FLAG) || !(sdata.flags & SimEntity.STATIC_FLAG))				{					rdata.flags &= ~RenderData.RENDER_FLAG;										// Update display position.					rdata.positionDisplay(mtx.a * sdata.x + mtx.c * sdata.y + mtx.tx - rdata.originX, mtx.b * sdata.x + mtx.d * sdata.y + mtx.ty - rdata.originY);				}								// Add to partition list if size is greater than 1 x 1.				if (aabb.xMax - aabb.xMin > 1.0001 || aabb.yMax - aabb.yMin > 1.0001)				{					partitionList.push(rdata);					rdata.flags |= DEPTH_PARTITION_FLAG;				}			}						computeDepthPartitions();						i = -1;						while (++i < l)			{				rdata = renderList[i];								if ((rdata.flags & DEPTH_PARTITION_FLAG) == 0)					rdata.depth += getDepthOffset(rdata.aabb);				else					rdata.flags &= ~DEPTH_PARTITION_FLAG;			}						sortFlag = true;		}				protected function computeDepthPartitions():void		{			var i:int = -1;			var j:int;			var l:int = partitionList.length;			var pA:SimRenderData;			var pB:SimRenderData;						while (++i < l)			{				pA = partitionList[i];								j = i;								while (++j < l)				{					pB = partitionList[j];										if (pB.aabb.xMax > pA.aabb.xMin && pB.aabb.yMax > pA.aabb.yMin)					{						pB.depth += pA.depth;					}					else if (pA.aabb.xMax > pB.aabb.xMin && pA.aabb.yMax > pB.aabb.yMin)					{						pA.depth += pB.depth;					}				}			}					partitionList.sortOn("depth", Array.NUMERIC);		}				protected function getDepthOffset(aabb:AABB):int		{			var i:int = partitionList.length;						while (--i > -1)			{				var pdata:SimRenderData = partitionList[i];								if (aabb.xMax > pdata.aabb.xMin && aabb.yMax > pdata.aabb.yMin)				{					return pdata.depth;				}			}						return 0;		}	}}