package com.sdg.sim.graph{	import flash.geom.Point;		public class GridPathFinder	{		protected var graph:Object;		protected var bestNode:PathFinderNode;		protected var neighborOffsets:Array;		protected var numNeighbors:int;		protected var uncheckedNodes:Array;				private var _costEvaluator:Function;		//private var _costCeiling:Number = 1;		/**		 * The original value of this was 1, however		 * this meant that you couldn't walk through avatars and Griefers could just block		 * your path. Since the cost solidity of a character is 2, changing this value to 3		 * causes the expected behavoir of walking around an avatar if possible, but walking		 * through them if not. Walking around furniture is kept impossible since the cost is		 * still to high.		 * Change by Molly fix for Bug 446		 */		private var _costCeiling:Number = 3;		private var _maxIterations:int;				private static const NEIGHBOR_OFFSETS:Array = [	new Point( 0,-1),	// n														new Point( 1,-1),	// ne														new Point( 1, 0),	// e														new Point( 1, 1),	// se														new Point( 0, 1),	// s														new Point(-1, 1),	// sw														new Point(-1, 0),	// w														new Point(-1,-1),	// nw														new Point( 0,-1),	// n		]				public function get costCeiling():Number		{			return _costCeiling;		}				public function set costCeiling(value:Number):void		{			_costCeiling = value;		}				public function get costEvaluator():Function		{			return _costEvaluator;		}				public function set costEvaluator(value:Function):void		{			_costEvaluator = value;		}				public function get maxIterations():int		{			return _maxIterations;		}				public function set maxIterations(value:int):void		{			_maxIterations = value;		}		public function GridPathFinder(maxIterations:int = 200, costEvaluator:Function = null)		{			_maxIterations = maxIterations;			_costEvaluator = costEvaluator;						neighborOffsets = NEIGHBOR_OFFSETS.slice();			numNeighbors = neighborOffsets.length;						bestNode = new PathFinderNode(0, 0, Number.MAX_VALUE);		}		public function findPath(x1:int, y1:int, x2:int, y2:int):Array		{			if (_costEvaluator == null) throw new Error("Property 'costEvaluator' must not be null.");						var cost:Number = _costEvaluator(x2, y2);			var node:PathFinderNode;			var iterations:int;			var path:Array;						// Exit if the destination cost is greater than the cost ceiling.			if (!(cost < _costCeiling))			{				trace("Destination 'cost' [" + cost + "] is not less than or equal to costCeiling.");				return null;			}						graph = {};			uncheckedNodes = [];						// Create top node.			node = new PathFinderNode(x1, y1, cost + Math.abs(x2 - x1) + Math.abs(y2 - y1));						// Add top node to graph.			graph[x1 + '_' + y1] = uncheckedNodes[0] = node;						// Build graph.			while (++iterations < _maxIterations)			{				// Get the next node.				node = uncheckedNodes.pop();								/*				if (node.cost < bestNode.cost);				{					bestNode = node;					trace('new bestNode', bestNode.x, bestNode.y, bestNode.cost);				}*/								// If the node coordinates match the destination, a path was found.				if (node.x == x2 && node.y == y2)				{					path = generatePath(node);					break;				}				else				{					// Add neighbors to the graph.					// If there are no more nodes to check, a path was not found.					if (addNeighbors(node, x2, y2) == 0)					{						trace("Path not found, no remaining nodes to check.");						break;					}				}			}						if (iterations == _maxIterations) trace("Path not found, reached iteration limit.");						// clean up			graph = null;			uncheckedNodes = null;						return path;		}				protected function addNeighbors(parent:PathFinderNode, x2:int, y2:int):int		{			var x1:int, y1:int;			var cost:Number;			var nodeName:String;			var node:PathFinderNode;			var ni:int;			var nl:int = uncheckedNodes.length;			var i:int = 0;			var inc:int;			var lastValid:Boolean;						for (i; i < numNeighbors; i += inc)			{				x1 = parent.x + neighborOffsets[i].x;				y1 = parent.y + neighborOffsets[i].y;								// Get the cost for the current position.				cost = _costEvaluator(x1, y1);								// If the cost is valid, add a new node to the neighbor list.				if (cost < _costCeiling)				{					nodeName = x1 + '_' + y1;										// If the node doesn't exist, add it to the neighbor list.					if (graph[nodeName] == null)					{						// Create a new node.						graph[nodeName] = node = new PathFinderNode(x1, y1, cost + Math.abs(x1 - x2) + Math.abs(y1 - y2), parent);						// Insert the node in descending order of cost.						ni = nl;												while (--ni > -1)						{							if (node.cost < uncheckedNodes[ni].cost)							{								uncheckedNodes.splice(ni + 1, 0, node);								break;							}						}											if (ni == -1) uncheckedNodes.unshift(node);								nl++;					}				}								if ((i & 1) == 0)				{					if (cost < _costCeiling)					{						inc = (lastValid) ? -1 : 2;						lastValid = true;					}					else					{						lastValid = false;						inc = 2;					}				}				else				{					inc = 3;				}			}						return nl;		}				protected function generatePath(node:PathFinderNode):Array		{			var path:Array = [];						while (node)			{				path.push(new Point(node.x, node.y));				node = node.parent;			}						path.reverse();			return path;		}	}}class PathFinderNode{	public var x:int;	public var y:int;	public var cost:Number;	public var parent:PathFinderNode;		public function PathFinderNode(x:int, y:int, cost:Number, parent:PathFinderNode = null)	{		this.x = x, this.y = y, this.cost = cost, this.parent = parent;	}}