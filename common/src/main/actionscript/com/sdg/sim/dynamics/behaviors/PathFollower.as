package com.sdg.sim.dynamics.behaviors{	import com.sdg.geom.Path;	import com.sdg.geom.PathInterpolator;	import com.sdg.sim.core.SimData;	import com.sdg.sim.core.SimEntity;	import com.sdg.sim.dynamics.IBehavior;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.Point;		public class PathFollower extends EventDispatcher implements IBehavior	{		public var speed:Number;				protected var data:SimData;		protected var complete:Boolean = false;		protected var interpolator:PathInterpolator;		protected var offset:Point;		protected var pos:Point = new Point();		protected var rotation:Number;				public function get isComplete():Boolean		{			return complete;		}				public function PathFollower(data:SimData, path:Path, speed:Number = .001)		{			this.data = data;			this.interpolator = new PathInterpolator(path);			this.speed = speed;		}				public function setPath(path:Path):void		{			interpolator.setPath(path);			rotation = NaN;		}				public function step(dt:Number):void		{			data.r = interpolator.currentAngle;			if( ( data.r < 0.8  ) && ( data.r > 0.7) ||	( data.r < -2.3 ) && ( data.r > -2.4) 	 )			{				 // bump the speed for tile projection  for these two quadrants				 //  directly toward and away from screen				 // the math is right but the speed 'appears' to be too slow				 				complete = interpolator.step(dt*( speed*1.7 ));			}			else			{				complete = interpolator.step(dt * speed);			}						interpolator.getPosition(pos);						data.position = new Point(pos.x, pos.y);			data.r = interpolator.currentAngle;						if (data.r != rotation)			{				rotation = data.r;				data.vx = speed * Math.cos(rotation);				data.vy = speed * Math.sin(rotation);								// Invalidate rotation.				data.owner.invalidate(SimEntity.ROTATED_FLAG);			}						if (complete)			{				data.vx = data.vy = 0;				dispatchEvent(new Event(Event.COMPLETE));			}		}	}}