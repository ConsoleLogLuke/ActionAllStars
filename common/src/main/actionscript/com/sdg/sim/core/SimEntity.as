package com.sdg.sim.core{	import com.sdg.events.SimEvent;	import com.sdg.geom.AABB;	import com.sdg.sim.dynamics.IIntegrator;	import com.sdg.sim.entity.IParticle;		import flash.events.EventDispatcher;		public class SimEntity extends EventDispatcher implements IParticle	{		public static const STATIC_FLAG:int 			= 0x01;		public static const COLLIDES_FLAG:int 			= 0x02;				public static const MOVED_FLAG:int 				= 0x08;		public static const RESIZED_FLAG:int 			= 0x10;		public static const ROTATED_FLAG:int 			= 0x20;		public static const INVALIDATION_FLAG_A:int 	= 0x40;		public static const INVALIDATION_FLAG_B:int 	= 0x80;				public static const AABB_RESIZED_FLAGS:int = MOVED_FLAG | RESIZED_FLAG | ROTATED_FLAG;		public static const INVALIDATION_FLAGS:int = MOVED_FLAG | RESIZED_FLAG | ROTATED_FLAG | INVALIDATION_FLAG_A | INVALIDATION_FLAG_B;				private static const NULL_SIMULATION:ISimulationManager = new NullSimulationManager();				protected var aabb:AABB = new AABB();		protected var sdata:SimData;		protected var simulation:ISimulationManager = NULL_SIMULATION;		protected var validating:Boolean;				private var _integrator:IIntegrator;				public function get data():SimData		{			return sdata;		}				public function get stateFlags():uint		{			return sdata.flags;		}				public function get mass():Number		{			return sdata.mass;		}				public function set mass(value:Number):void		{			if (value > 0)			{				sdata.mass = value;				sdata.invMass = 1 / value;			}			else sdata.mass = sdata.invMass = 0;		}				public function get x():Number		{			return sdata.x;		}				public function set x(value:Number):void		{			if (value != sdata.x)			{				sdata.x = value;								invalidate(MOVED_FLAG);			}		}				public function get y():Number		{			return sdata.y;		}				public function set y(value:Number):void		{			if (value != sdata.y)			{				sdata.y = value;				invalidate(MOVED_FLAG);			}		}				public function get vx():Number		{			return sdata.vx;		}				public function set vx(value:Number):void		{			sdata.vx = value;		}				public function get vy():Number		{			return sdata.vy;		}				public function set vy(value:Number):void		{			sdata.vy = value;		}				public function get rotation():Number		{			return sdata.r;		}				public function set rotation(value:Number):void		{			sdata.r = value;			invalidate(ROTATED_FLAG);		}				public function applyForce(x:Number, y:Number):void		{			sdata.fx += x, sdata.fy += y;		}				public function applyImpulse(x:Number, y:Number):void		{			sdata.vx += sdata.invMass * x;			sdata.vy += sdata.invMass * y;		}				public function get integrator():IIntegrator		{			return _integrator;		}				public function set integrator(value:IIntegrator):void		{			if (value != _integrator)			{				if (_integrator) simulation.removeIntegrator(_integrator);				if (value) simulation.addIntegrator(value);								_integrator = value;								motionEnabled = (_integrator != null);			}		}				public function get motionEnabled():Boolean		{			return (sdata.flags & STATIC_FLAG) == 0;		}				public function set motionEnabled(value:Boolean):void		{			if (value == (sdata.flags & STATIC_FLAG))			{				if (value)				{					sdata.flags &= ~STATIC_FLAG;					if (_integrator) simulation.addIntegrator(_integrator);					dispatchEvent(new SimEvent(SimEvent.MOTION_ENABLED));				}				else				{					sdata.flags |= STATIC_FLAG;					if (_integrator) simulation.removeIntegrator(_integrator);					dispatchEvent(new SimEvent(SimEvent.MOTION_DISABLED));				}								invalidate(MOVED_FLAG);			}		}				public function get simData():SimData		{			return sdata;		}				public function SimEntity(simData:SimData = null)		{			sdata = (simData == null) ? new SimData(this) : simData;		}				public function angleTo(x:Number, y:Number):Number		{			return Math.atan2(y - sdata.y, x - sdata.x);		}				public function distanceTo(x:Number, y:Number):Number		{			return Math.sqrt( (x - sdata.x) * (x - sdata.x) + (y - sdata.y) * (y - sdata.y) );		}				public function rotate(theta:Number):void		{			rotation = sdata.r + theta;		}				public function getAABB():AABB		{			validateNow();						return new AABB(aabb.xMin + sdata.x, aabb.yMin + sdata.y, 							aabb.xMax + sdata.x, aabb.yMax + sdata.y);		}				public function getLocalAABB(ox:Number = 0, oy:Number = 0):AABB		{			validateNow();						return new AABB(aabb.xMin + ox, aabb.yMin + oy, 							aabb.xMax + ox, aabb.yMax + oy);		}				public function validateNow():void		{			// Only proceed if we are not already validating and			// any validation flags are true.			if (!validating && (sdata.flags & INVALIDATION_FLAGS))			{				// Set invalid flag to true to block subsequent validateNow() 				// calls until validation is finished.				validating = true;								// Do validation.				validate();								// Set validation flag back to false.				validating = false;								// Dispatch validation event.				if (hasEventListener(SimEvent.VALIDATED))				{					dispatchEvent(new SimEvent(SimEvent.VALIDATED));				}								// Reset validation flags.				sdata.flags &= ~INVALIDATION_FLAGS;			}		}				public function invalidate(flag:uint):void		{			if ((sdata.flags & INVALIDATION_FLAGS) == 0)			{				simulation.invalidateMember(this);			}						sdata.flags |= flag;		}				protected function validate():void		{			if (sdata.flags & ROTATED_FLAG)			{				sdata.r11 = Math.cos(sdata.r);				sdata.r21 = Math.sin(sdata.r);			}		}				internal function getSimulation():ISimulation		{			return simulation as ISimulation;		}				internal function setSimulation(sim:ISimulation):void		{			if (simulation != NULL_SIMULATION)			{				if (motionEnabled && _integrator)					simulation.removeIntegrator(_integrator);								dispatchEvent(new SimEvent(SimEvent.REMOVED));			}						simulation = (sim == null) ? NULL_SIMULATION : sim;						if (simulation != NULL_SIMULATION)			{				if (motionEnabled && _integrator)					simulation.addIntegrator(_integrator);								dispatchEvent(new SimEvent(SimEvent.ADDED));			}		}	}}