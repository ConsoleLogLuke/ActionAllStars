package com.sdg.sim.map{		import com.sdg.collections.Array2;	import com.sdg.geom.AABB;	import com.sdg.geom.Path;	import com.sdg.model.PointCollection;	import com.sdg.sim.core.Simulation;	import com.sdg.sim.entity.IMapOccupant;	import com.sdg.sim.graph.GridPathFinder;		import flash.geom.Point;	import flash.utils.Dictionary;		public class TileMap extends Simulation implements IOccupancyMap	{		public static const TILE_SIZE:Number = 60;		public static const ISO_ANGLE:Number = 22.31;				private var _tileGrid:Array2;		private var _occupancyMap:Dictionary = new Dictionary(true);		private var _pathFinder:GridPathFinder;		protected var _orginOffX:uint;		protected var _orginOffY:uint;				public function get columns():uint		{			return _tileGrid.width;		}				public function set columns(value:uint):void		{			_tileGrid.width = value;		}				public function get rows():uint		{			return _tileGrid.height;		}				public function set rows(value:uint):void		{			_tileGrid.height = value;		}				public function TileMap(columns:uint = 0, rows:uint = 0, tileList:Array = null, orginOffX:uint = 0, orginOffY:uint = 0)		{			_orginOffX = orginOffX;			_orginOffY = orginOffY;			_tileGrid = new Array2(columns, rows, tileList);			_pathFinder = new GridPathFinder(_tileGrid.size >> 1);		}				//--------------------------------------------------------------------------		//		//  Tiles		//		//--------------------------------------------------------------------------				public function reset(width:uint = 0, height:uint = 0, tileList:Array = null):void		{			removeAllOccupants();			_tileGrid.reset(width, height, tileList);			_pathFinder.maxIterations = _tileGrid.size >> 1;		}				public function getTile(col:int, row:int):IOccupancyTile		{			col += _orginOffX;			row += _orginOffX;			return _tileGrid.get(col, row);		}				public function getTileSet(setID:String, returnCoordinates:Boolean = false):Array		{			// return an array of every tile in the map whose setID matches input setID			var tiles:Array = [];			var ci:int = 0;			var ri:int;			var tile:IOccupancyTile;			for (ci; ci < columns; ci++)			{				for (ri = 0; ri < rows; ri++)				{					tile = _tileGrid.get(ci, ri);					if (tile && tile.tileSetID == setID)					{						// Return tiles unless "returnCoordinates" is set to true, in whihc case return coordinate points.						tiles.push((!returnCoordinates) ? tile : new Point(ci - _orginOffX, ri - _orginOffY));					}				}								ri = 0;			}						return tiles;		}				public function getAllOpenTileCoordinates():PointCollection		{			// Return an Array of non occupied tiles coordinates			var points:PointCollection = new PointCollection();			var ci:int = 0;			var ri:int;			var tile:IOccupancyTile;			for (ci; ci < columns; ci++)			{				for (ri = 0; ri < rows; ri++)				{					tile = _tileGrid.get(ci, ri);					if (tile && tile.getOccupant() == null)					{						// Found non occupied tile.						points.push(new Point(ci - _orginOffX, ri - _orginOffY));					}				}								ri = 0;			}						return points;		}				public function getOpenTileCoordinate(requiredTileSetId:String = null):Point		{			var ci:int = 0;			var ri:int;			var tile:IOccupancyTile;			for (ci; ci < columns; ci++)			{				for (ri = 0; ri < rows; ri++)				{					tile = _tileGrid.get(ci, ri);					if (tile && ((requiredTileSetId) ? (tile.tileSetID == requiredTileSetId) : true) && tile.getOccupant() == null)					{						// Found non occupied tile.						return new Point(ci - _orginOffX, ri - _orginOffY);					}				}								ri = 0;			}						return null;		}				public function getFirstTileCoordinate(requiredTileSetId:String = null):Point		{			var ci:int = 0;			var ri:int;			var tile:IOccupancyTile;			for (ci; ci < columns; ci++)			{				for (ri = 0; ri < rows; ri++)				{					tile = _tileGrid.get(ci, ri);					if (tile && ((requiredTileSetId) ? (tile.tileSetID == requiredTileSetId) : true))					{						// Found non occupied tile.						return new Point(ci - _orginOffX, ri - _orginOffY);					}				}								ri = 0;			}						return null;		}				public function getNearestOpenTileCoordinate(initialX:int, initialY:int, requiredTileSetId:String = null):Point		{			// Return coordinates to the nearest unoccupied tile.			// Dont return coordinates to a trigger tile.			var ci:int = 0;			var ri:int;			var nearestCoordinate:Point;			var currentDistance:uint = uint.MAX_VALUE;			for (ci; ci < columns; ci++)			{				for (ri = 0; ri < rows; ri++)				{					// Determine the total distance from the initial coordinates.					var xDistance:uint = Math.abs(initialX - ci);					var yDistance:uint = Math.abs(initialY - ri);					var distance:uint = xDistance + yDistance;					// If the coordinates are further than a					// previous tile, move to the next tile.					if (distance >= currentDistance) continue;										// Get a reference to the tile at these coordinates.					var tile:IOccupancyTile = _tileGrid.get(ci, ri);					if (tile == null) continue;										// Make sure the tile is not occupied.					if (tile.getOccupant() != null) continue;										// Make sure it is not a trigger tile.					if ((tile as TriggerTile) != null) continue;										// This is a potential tile.					nearestCoordinate = new Point(ci, ri);					currentDistance = distance;				}								ri = 0;			}						// Return the nearest coordinates we could find.			return nearestCoordinate;		}				public function getFurthestTilePositionInDirectPathFromPoint(startX:int, startY:int, xDir:int, yDir:int):Point		{			// Start at specified coordinates and traverse the tiles in the specified direction until we find a non-tile.			// Return the tile just before the non-tile.			var x:int = startX;			var y:int = startY;			var tile:IOccupancyTile = getTile(x, y);			var lastPosTile:IOccupancyTile = tile;			xDir = (xDir) ? Math.min(xDir, 1) : Math.max(xDir, -1);			yDir = (yDir) ? Math.min(yDir, 1) : Math.max(yDir, -1);			do			{				x += xDir;				y += yDir;				tile = getTile(x, y);				if (tile) lastPosTile = tile;			}			while (tile != null);						x -= xDir;			y -= yDir;			return new Point(x, y);		}				public function setTile(col:int, row:int, tile:IOccupancyTile):void		{			col += _orginOffX;			row += _orginOffY;			_tileGrid.set(col, row, tile);		}				public function setAllTiles(tileList:Array):void		{			removeAllOccupants();			_tileGrid.setAll(tileList);		}				public function setSize(columns:uint, rows:uint):void		{			_tileGrid.setSize(columns, rows);		}				//--------------------------------------------------------------------------		//		//  Occupancy		//		//--------------------------------------------------------------------------				public function addOccupant(entity:IMapOccupant, x:Number = NaN, y:Number = NaN):Boolean		{		//	trace("TileMap.addOccupant " +new Error().getStackTrace());			// Clear current occupancy.			removeOccupant(entity);						var tiles:Array = getOccupyingTiles(entity, x, y);					if (tiles)			{				var i:int = tiles.length;								// Set occupancy on each tile.				while (--i > -1) 				{					if (tiles[i] && tiles[i].validateOccupancy(entity))						tiles[i].setOccupant(entity);				}								// Map the tile list to the occupying entity.				_occupancyMap[entity] = tiles;								return true;			}						return false;		}				public function containsOccupant(entity:IMapOccupant):Boolean		{			return _occupancyMap[entity] != null;		}				public function getOccupant(x:Number, y:Number):IMapOccupant		{			var tile:IOccupancyTile = _tileGrid.get(x, y);			return (tile) ? tile.getOccupant() : null;		}				public function removeOccupant(entity:IMapOccupant):void		{			var tiles:Array = _occupancyMap[entity];						if (tiles)			{				var i:int = tiles.length;								while (--i > -1)					if (tiles[i] && /* han sanity check */ tiles[i].getOccupant()==entity) tiles[i].setOccupant(null);									delete _occupancyMap[entity];			}		}				public function removeAllOccupants():void		{			for each (var tiles:Array in _occupancyMap)			{				for (var i:int = 0; i < tiles.length; i++)					if (tiles[i]) tiles[i].setOccupant(null);			}						_occupancyMap = new Dictionary(true);		}				public function validateOccupancy(entity:IMapOccupant, x:Number = NaN, y:Number = NaN):Boolean		{			var retval:Boolean=getValidOccupyingTiles(entity, x, y)!=null;		//	trace("tilemap.validateOccupancy: "+retval+" "+new Error().getStackTrace());			return retval;		}				public function findPath(entity:IMapOccupant, tx:Number, ty:Number):Path		{			var aabb:AABB = entity.getLocalAABB();						tx = tx >> 0;			ty = ty >> 0;						var tileOccupant:IMapOccupant = getOccupant(tx + aabb.xMax, ty + aabb.xMax);						if (tileOccupant != null && tileOccupant.solidity > 0)			{				return null;			}						/*if (!validateOccupancy(entity, tx + aabb.xMax, ty + aabb.xMax))			{				return null;			}*/						var tile:IOccupancyTile;			var path:Path;						_pathFinder.costEvaluator = function(col:int, row:int):Number			{				tile = getTile(col, row);				return (tile) ? tile.getTraversalCost(entity) : Number.MAX_VALUE;			}						var points:Array = _pathFinder.findPath(entity.x >> 0, entity.y >> 0, tx >> 0, ty >> 0);						if (points)			{				path = new Path();				path.moveTo(entity.x, entity.y);				path.addPoints(points.slice(1), aabb.xMax, aabb.xMax);			}						return path;		}				protected function getOccupyingTiles(entity:IMapOccupant, x:Number = NaN, y:Number = NaN):Array		{			x = isNaN(x) ? entity.x : x;			y = isNaN(y) ? entity.y : y;			x += _orginOffX;			y += _orginOffY;						var aabb:AABB = entity.getLocalAABB(x, y);			var w:int = Math.max(Math.ceil(aabb.xMax - aabb.xMin), 1);			var h:int = Math.max(Math.ceil(aabb.yMax - aabb.yMin), 1);		//	trace("width "+w+" height "+h+" xmax "+aabb.xMax+" xmin "+aabb.xMin+" ymax "+aabb.yMax+" ymin "+aabb.yMin);			return _tileGrid.getRect(aabb.xMin >> 0, aabb.yMin >> 0, w, h);		}				protected function getValidOccupyingTiles(entity:IMapOccupant, x:Number = NaN, y:Number = NaN):Array		{			x = isNaN(x) ? entity.x : x;			y = isNaN(y) ? entity.y : y;			x += _orginOffX;			y += _orginOffY;			var aabb:AABB = entity.getLocalAABB(x, y);			var w:int = Math.max(Math.ceil(aabb.xMax - aabb.xMin), 1);			var h:int = Math.max(Math.ceil(aabb.yMax - aabb.yMin), 1);			var tiles:Array = _tileGrid.getRect(aabb.xMin >> 0, aabb.yMin >> 0, w, h);			var i:int = tiles.length;		//	trace("tiles length "+i);						// Exit if the tile list length does not match the entity footprint.								if (i != w * h) return null;						// Validate each tile.							while (--i > -1)			{		//		if(tiles[i]) trace(" i "+ tiles[i].validateOccupancy(entity));				if (!tiles[i] || !tiles[i].validateOccupancy(entity)) return null;			}						return tiles;		}	}}