package com.sdg.geom{	import com.sdg.geom.IShape;	import com.sdg.geom.IShapeCursor;	import com.sdg.geom.PathCursor;	import flash.geom.Point;	import flash.geom.Rectangle;		public class Path implements IShape	{		public static const SEG_MOVETO:int = 1;		public static const SEG_LINETO:int = 2;		public static const SEG_COORDS:Array = [0, 2, 2];				internal var coords:Array = [];		internal var types:Array = [];		internal var coordIndex:int = -1;		internal var segIndex:int = -1;				public function get numSegments():uint		{			return segIndex + 1;		}				public function Path(shape:IShape = null)		{			if (shape) addShape(shape);		}				public function clear():void		{			coords.length = types.length = 0;			segIndex = coordIndex = -1;		}				public function moveTo(x:Number, y:Number):void		{			if (types[segIndex] == SEG_MOVETO)			{				coords[coordIndex] = x;				coords[coordIndex] = y;			}			else			{				types[++segIndex] = SEG_MOVETO;				coords[++coordIndex] = x;				coords[++coordIndex] = y;			}		}		public function lineTo(x:Number, y:Number):void		{			if (segIndex == -1) throw new Error("Cannot add lineTo, moveTo() must be added first.");			types[++segIndex] = SEG_LINETO;			coords[++coordIndex] = x;			coords[++coordIndex] = y;		}				public function addPoints(points:Array, ox:Number = 0, oy:Number = 0):void		{			var i:int = 0;			var l:Number = points.length;			var p:Point;						if (segIndex == -1)			{				p = points[0] as Point;				moveTo(p.x + ox, p.y + oy);				i++;			}						for (i; i < l; i++)			{				p = points[i] as Point;				lineTo(p.x + ox, p.y + oy);			}		}				public function addShape(shape:IShape):void		{			var cursor:IShapeCursor = shape.getCursor();			var coords:Array = [];						while (cursor.hasNext())			{				cursor.next();								switch (cursor.currentSegment(coords))				{					case SEG_MOVETO:						moveTo(coords[0], coords[1]);						break;					case SEG_LINETO:						lineTo(coords[0], coords[1]);						break;				}								coords.length = 0;			}		}		public function getRect():Rectangle		{			var x1:Number, y1:Number, x2:Number, y2:Number;						var i:int = coordIndex;						if (i > 0)			{				x1 = x2 = coords[i--];				y1 = y2 = coords[i];							while (i > 0)				{					var x:Number = coords[--i], y:Number = coords[--i];									if (x < x1) x1 = x;					if (y < y1) y1 = y;					if (x > x2) x2 = x;					if (y > y2) y2 = y;				}							return new Rectangle(x1, y1, x2 - x1, y2 - y1);			}			else			{				return new Rectangle(0, 0, 0, 0);			}		}				public function getCursor():IShapeCursor		{			return new PathCursor(this);		}				public function clone():IShape		{			var path:Path = new Path();						path.coords = coords.slice();			path.types = types.slice();			path.segIndex = segIndex;			path.coordIndex = coordIndex;						return path;		}	}}