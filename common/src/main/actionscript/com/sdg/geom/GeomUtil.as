package com.sdg.geom{	import flash.geom.*;		public class GeomUtil	{				public static const INV_PI:Number  				= 1 / Math.PI;		public static const INV_PI_2:Number  			= 1 / (Math.PI * 2);		public static const PI_2:Number 				= Math.PI * 2;		public static const PI_OVER_180:Number 			= Math.PI / 180;		public static const _180_OVER_PI:Number 		= 180 / Math.PI;		public static const RADIANS_45:Number 			= Math.PI / 4;		public static const RADIANS_90:Number 			= Math.PI / 2;		public static const RADIANS_360:Number 			= Math.PI * 2;				internal static const NULL_SHAPE_CURSOR:IShapeCursor = new Path().getCursor();				public static function radiansToDegrees(rads:Number):Number		{			return rads * _180_OVER_PI;		}				public static function degreesToRadians(degrees:Number):Number		{			return degrees * PI_OVER_180;		}				public static function toUnitRadians(rads:Number):Number		{			return (rads < 0 ? 0 : PI_2) - rads % Math.PI;		}				public static function toUnitDegrees(rads:Number):Number		{			return ((rads < 0 ? 0 : PI_2) - rads % Math.PI) * _180_OVER_PI;		}				public static function angleToFloat(rads:Number):Number		{			return ((-rads * INV_PI + 1) * .5 + .5) % 1;		}				public static function angleToIndex(rads:Number, range:int = 1):int		{			return Math.round(angleToFloat(rads) * range) % range;		}				public static function createIsoMatrix(tileWidth:Number, tileHeight:Number, tx:Number = 0, ty:Number = 0, rotation:Number = NaN):Matrix		{			if (isNaN(rotation)) rotation = RADIANS_45;						var matrix:Matrix = new Matrix();			var hr:Number = 1 / Math.sqrt(2);			matrix.createBox(tileWidth * hr, tileHeight * hr, rotation, tx, ty);			return matrix;		}	}}