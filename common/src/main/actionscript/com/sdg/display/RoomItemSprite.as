package com.sdg.display{		import com.boostworthy.animation.easing.Transitions;	import com.boostworthy.animation.management.AnimationManager;	import com.boostworthy.animation.rendering.RenderMethod;	import com.sdg.animation.AnimationSetPlayer;	import com.sdg.animation.AnimationSetResource;	import com.sdg.business.resource.AnimationSetResourceLoader;	import com.sdg.core.IProgressInfo;	import com.sdg.display.render.RenderData;	import com.sdg.events.RoomItemDisplayEvent;	import com.sdg.events.SDGAnimationEvent;	import com.sdg.model.ModelLocator;	import com.sdg.model.Reward;	import com.sdg.model.SdgItem;	import com.sdg.model.SdgItemClassId;	import com.sdg.net.Environment;	import com.sdg.net.RemoteSoundBank;	import com.sdg.utils.BitmapUtil;	import com.sdg.utils.Constants;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.utils.Timer;		public class RoomItemSprite extends RoomItemDisplayBase implements IRoomItemDisplay	{		protected static const _animationManager:AnimationManager = new AnimationManager();				public static const DEFAULT_ANIMATION:String = 'rest';		public static const TOKEN_SOUND_ID:int = 101;		public static const XP_SOUND_ID:int = 102;						protected var animationPlayer:AnimationSetPlayer;		protected var _resource:AnimationSetResourceLoader;		protected var _spriteRenderer:SpriteSheetRenderer;		protected var _useEmoteBubble:Boolean = true;		protected var _floorMarker:DisplayObject;				private var _self:IRoomItemDisplay;		private var _animation:String;		private var _orientation:uint;		private var _isDestroy:Boolean;		private var _mouseArea:Sprite;		private var _spriteLoaded:Boolean;		private var _bursts:int;				private static var _remoteSoundBank:RemoteSoundBank;				public function RoomItemSprite(item:SdgItem)		{			_self = this;			if (!_remoteSoundBank) _remoteSoundBank = new RemoteSoundBank();			_spriteLoaded = false;						_resource = new AnimationSetResourceLoader(item);			_resource.addEventListener(Event.COMPLETE, loadCompleteHandler);						super(item);						buttonMode = true;						_spriteRenderer = new SpriteSheetRenderer();						_mouseArea = new Sprite();			_mouseArea.addEventListener(MouseEvent.MOUSE_OVER, onMouseAreaOver);			_mouseArea.addEventListener(MouseEvent.MOUSE_DOWN, onMouseAreaDown);			_mouseArea.addEventListener(MouseEvent.CLICK, onMouseAreaClick);						// Set hit area.			// This is the area that flash uses to determine mouse interactivity.			hitArea = _mouseArea;						// Create animation player.			// This handles rendering the sprite sheet at specific indexes depending on the current animation.			animationPlayer = new AnimationSetPlayer();			animationPlayer.addSpriteRenderer(_spriteRenderer);			animationPlayer.addEventListener(SDGAnimationEvent.ANIMATION_COMPLETE, animationCompleteHandler);						// Listen for movement.			_renderItem.data.addEventListener(RenderData.MOVE, onRenderDataMove);						// Add displays.			addChild(_spriteRenderer);			addChild(_mouseArea);		}				////////////////////		// PUBLIC METHODS		////////////////////				override public function activate():void		{			animationPlayer.play();		}				override public function deactivate():void		{			animationPlayer.stop();		}				// remove resources attached to original this object		override public function destroy():void		{			//			// IMPORTANT			//			// Make sure it's not the loccal user avatar.			// We don't want to destroy that avatar.			if (item.itemClassId == SdgItemClassId.AVATAR && item.avatarId == ModelLocator.getInstance().avatar.avatarId) return;						// Handle all clean up for the item sprite.			// Make sure we only destroy once.			if (_isDestroy == true) return;			_isDestroy = true;						// Clean up sprite renderer.			removeChild(_spriteRenderer);			animationPlayer.removeSpriteRenderer(_spriteRenderer);			_spriteRenderer.destroy();			_spriteRenderer = null;						// Clean up resource.			_resource.removeEventListener(Event.COMPLETE, loadCompleteHandler);			_resource.destroy();			_resource = null;						// Clean up animation player.			animationPlayer.removeEventListener(SDGAnimationEvent.ANIMATION_COMPLETE, animationCompleteHandler);			animationPlayer.stop();			animationPlayer.removeAllResources(); 			animationPlayer = null;						// CLean up mouse area listeners.			_mouseArea.removeEventListener(MouseEvent.MOUSE_OVER, onMouseAreaOver);			_mouseArea.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseAreaDown);			_mouseArea.removeEventListener(MouseEvent.CLICK, onMouseAreaClick);						// Clean up render item listener.			_renderItem.data.removeEventListener(RenderData.MOVE, onRenderDataMove);						super.destroy();		}		public function getImageRect(update:Boolean = false):Rectangle		{			// Using update can be expensive.			// This (updateImageArea) will update the mouseArea to reflect the non-transparent pixels in the currently rendred sprite sheet.			if (update) updateImageArea(_spriteRenderer.currentSpriteIndex);						return (!_mouseArea) ? getRect(this) : _mouseArea.getRect(this);		}				override public function load():void		{			_resource.load();		}				public function playAnimation(name:String):void		{			//HAN			if (name==null && _animation==DEFAULT_ANIMATION)			{				trace("skipping redundant anim");			}			else			{				_animation = (name == null) ? DEFAULT_ANIMATION : name;				var animation:String = _animation + _orientation;				animationPlayer.playAnimation(animation);			}		}				public function showSublevelUp(newLevel:int):void		{			var sublevelUp:SublevelUpEffect = new SublevelUpEffect();			sublevelUp.numbers.gotoAndStop(newLevel);			sublevelUp.x = 60;			sublevelUp.y = 20;			addChild(sublevelUp);			sublevelUp.addEventListener(Event.COMPLETE, onSublevelUpComplete, false, 0, true);		}				private function onSublevelUpComplete(event:Event):void		{			var sublevelUp:SublevelUpEffect = event.currentTarget as SublevelUpEffect;			sublevelUp.removeEventListener(Event.COMPLETE, onSublevelUpComplete);			removeChild(sublevelUp);		}				public function showBurstOverhead(rewardsArray:Array):void		{			var rewardString:String;			var rewardArray:Array;			var rewardTypeId:Object;			var value:int;			var frame:String;			var sfxId:int;			var burstOver:BurstOverhead;						for each (rewardString in rewardsArray)			{				rewardArray = rewardString.split(",");				rewardTypeId = rewardArray[0];				value = rewardArray[1];								if (rewardTypeId == Reward.CURRENCY)				{					frame = "token";					sfxId = TOKEN_SOUND_ID;				}				else if (rewardTypeId == Reward.EXPERIENCE)				{					frame = "point";					sfxId = XP_SOUND_ID;				}								_remoteSoundBank.playSound(Environment.getAssetUrl() + Constants.SFX_URL + sfxId);								burstOver = new BurstOverhead();				burstOver.reward.amount.text = value;				burstOver.reward.gotoAndStop(frame);				burstOver.x = 55;				burstOver.y = -2 + (-30 * _bursts);				_bursts++;				addChild(burstOver);				burstOver.addEventListener(Event.COMPLETE, onBurstOverComplete, false, 0, true);			}		}				private function onBurstOverComplete(event:Event):void		{			var burstOver:BurstOverhead = event.currentTarget as BurstOverhead;			burstOver.removeEventListener(Event.COMPLETE, onBurstOverComplete);			removeChild(burstOver);						_bursts--;		}				public function showOverheadMessage(message:String, strokeColor:uint,sfxId:String=null):void		{			if (_isDestroy)				return;						if (sfxId)			{				_remoteSoundBank.playSound(Environment.getAssetUrl() + Constants.SFX_URL + sfxId);			}						var imageRect:Rectangle = getRect(this);						var overheadMessage:OverheadMessage = new OverheadMessage(strokeColor);			addChild(overheadMessage);			overheadMessage.x = (imageRect.x + imageRect.width * .5) - 2;			overheadMessage.y = imageRect.y - overheadMessage.height - 2 + 50;			overheadMessage.showMessage(message);						_animationManager.property(overheadMessage, "y", overheadMessage.y - 50, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage, "scaleX", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage, "scaleY", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage, "alpha", 0, 1000, Transitions.CUBIC_IN, RenderMethod.TIMER);						// Create a timer used to remove the message after a specified amount of time.			var textFieldTimer:Timer = new Timer(Constants.OVERHEAD_MESSAGE_TIMEOUT);			textFieldTimer.addEventListener(TimerEvent.TIMER, onTimerInterval);			textFieldTimer.start();						function onTimerInterval(e:TimerEvent):void			{				textFieldTimer.reset();				textFieldTimer.removeEventListener(TimerEvent.TIMER, onTimerInterval);				removeChild(overheadMessage);			}		}				public function showDualOverheadMessage(message1:String, message2:String, strokeColor1:uint, strokeColor2:uint, sfxId1:String=null, sfxId2:String=null):void		{			if (_isDestroy)				return;			if (sfxId1)				_remoteSoundBank.playSound(Environment.getAssetUrl() + Constants.SFX_URL + sfxId1);							var imageRect:Rectangle = getRect(this);						var overheadMessage1:OverheadMessage = new OverheadMessage(strokeColor1);			addChild(overheadMessage1);			overheadMessage1.x = (imageRect.x + imageRect.width * .5) - 2;			overheadMessage1.y = imageRect.y - overheadMessage1.height - 2 + 50;			overheadMessage1.showMessage(message1);						_animationManager.property(overheadMessage1, "y", overheadMessage1.y - 50, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage1, "scaleX", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage1, "scaleY", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);			_animationManager.property(overheadMessage1, "alpha", 0, 1000, Transitions.CUBIC_IN, RenderMethod.TIMER);						// Create a timer used to remove the message after a specified amount of time.			var textFieldTimer1:Timer = new Timer(Constants.OVERHEAD_MESSAGE_TIMEOUT);			textFieldTimer1.addEventListener(TimerEvent.TIMER, onFirstTimerInterval);			textFieldTimer1.start();						function onFirstTimerInterval(e:TimerEvent):void			{				textFieldTimer1.reset();				textFieldTimer1.removeEventListener(TimerEvent.TIMER, onFirstTimerInterval);				removeChild(overheadMessage1);								if (_isDestroy)				{					return;				}								if (sfxId2)					_remoteSoundBank.playSound(Environment.getAssetUrl() + Constants.SFX_URL + sfxId2);								var overheadMessage2:OverheadMessage = new OverheadMessage(strokeColor2);				addChild(overheadMessage2);				overheadMessage2.x = (imageRect.x + imageRect.width * .5) - 2;				overheadMessage2.y = imageRect.y - overheadMessage2.height - 2 + 50;				overheadMessage2.showMessage(message2);								_animationManager.property(overheadMessage2, "y", overheadMessage2.y - 50, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);				_animationManager.property(overheadMessage2, "scaleX", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);				_animationManager.property(overheadMessage2, "scaleY", 3, 1000, Transitions.CUBIC_OUT, RenderMethod.TIMER);				_animationManager.property(overheadMessage2, "alpha", 0, 1000, Transitions.CUBIC_IN, RenderMethod.TIMER);								// Create a timer used to remove the message after a specified amount of time.				var textFieldTimer2:Timer = new Timer(Constants.OVERHEAD_MESSAGE_TIMEOUT);				textFieldTimer2.addEventListener(TimerEvent.TIMER, onSecondTimerInterval);				textFieldTimer2.start();								function onSecondTimerInterval(e:TimerEvent):void				{					textFieldTimer2.reset();					textFieldTimer2.removeEventListener(TimerEvent.TIMER, onSecondTimerInterval);					removeChild(overheadMessage2);				}			}		}				public function setAnimationResource(animResource:AnimationSetResource):void		{			_resource.reset();			animationPlayer.removeAllResources();			animationPlayer.addResourceList([animResource]);			initDisplay();		}				////////////////////		// PROTECTED METHODS		////////////////////				protected function getAlphaPixel(x:uint, y:uint):Boolean		{			if (!_spriteRenderer || !_spriteRenderer.bitmapData)				return false;						return _spriteRenderer.bitmapData.getPixel32(x, y) == 0;		}				protected function initDisplay():void		{			playAnimation(_animation);						updateImageArea();						activate();						dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.CONTENT, this));		}				////////////////////		// PRIVATE METHODS		////////////////////				private function render():void		{			// If there is a floor marker,			// Update it's position.			positionFloorMarker();						// Re-position resolve icon.			positionResolveIcon();		}				private function updateImageArea(useSpriteCellIndex:int = 0):void		{			var rect:Rectangle = (_spriteRenderer.spriteSheet) ? 			BitmapUtil.getAlphaBounds(_spriteRenderer.spriteSheet.getSprite(useSpriteCellIndex)) : new Rectangle();						// Redraw mouse area.			_mouseArea.x = rect.x;			_mouseArea.y = rect.y;			_mouseArea.graphics.clear();			_mouseArea.graphics.beginFill(0x00ff00, 0);			_mouseArea.graphics.drawRect(0, 0, rect.width, rect.height);						render();		}				private function positionFloorMarker():void		{			if (!_floorMarker) return;			var offY:Number = 6;			// Only show the floor marker if the sprite has loaded.			_floorMarker.visible = _spriteLoaded;			_floorMarker.x = _renderItem.originX;			_floorMarker.y = _renderItem.originY + offY;		}				////////////////////		// GET/SET METHODS		////////////////////				public function set floorMarker(value:DisplayObject):void		{			if (value == _floorMarker) return;						// Remove previous floor marker.			if (_floorMarker != null)			{				removeChild(_floorMarker);			}						// Set new floor marker.			_floorMarker = value;						if (_floorMarker == null) return;						// Add to display.			addChildAt(_floorMarker, 0);						render();		}				public function get content():DisplayObject		{			return this;		}				public function get orientation():uint		{			return _orientation;		}				public function set orientation(value:uint):void		{			if (value != _orientation)			{				_orientation = value;				animationPlayer.currentAnimation = _animation + _orientation;			}		}				public function get progressInfo():IProgressInfo		{			return _resource;		}				public function get resource():AnimationSetResourceLoader		{			return _resource;		}				public function get currentAnimation():String		{			return animationPlayer.currentAnimation;		}				override public function get filters():Array		{			return _spriteRenderer.filters;		}		override public function set filters(value:Array):void		{			if(_spriteRenderer != null)			{				_spriteRenderer.filters = value;			}		}				////////////////////		// EVENT HANDLERS		////////////////////				protected function animationCompleteHandler(event:SDGAnimationEvent):void		{			// If item is moving, play walk anim.			if (item.entity.motionEnabled)			{				trace('Animation complete: ' + _animation + '; Playing walk');				playAnimation('walk');			}			else if (_animation != DEFAULT_ANIMATION)			{				trace('Animation complete: ' + _animation + '; Playing default: ' +  DEFAULT_ANIMATION);				playAnimation(DEFAULT_ANIMATION);			}			else			{				trace("skipping, since it's default");			}		}				protected function loadCompleteHandler(event:Event):void		{			animationPlayer.removeAllResources();			animationPlayer.addResourceList(_resource.content);						// Set flag.			_spriteLoaded = true;						initDisplay();		}				private function onMouseAreaOver(e:MouseEvent):void		{			// Dispatch custom mouse over.			dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.MOUSE_OVER_ITEM, _self, true));			_mouseArea.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);						function onMouseOut(e:MouseEvent):void			{				_mouseArea.removeEventListener(MouseEvent.MOUSE_OUT, onMouseOut);				// Dispatch custom mouse out.				dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.MOUSE_OUT_ITEM, _self, true));			}		}				private function onMouseAreaDown(e:MouseEvent):void		{			// Dispatch custom mouse down.			dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.MOUSE_DOWN_ITEM, _self, true));		}				private function onMouseAreaClick(e:MouseEvent):void		{			// Dispatch custom mouse click.			dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.MOUSE_CLICK_ITEM, _self, true));		}				private function onRenderDataMove(e:Event):void		{			dispatchEvent(new RoomItemDisplayEvent(RoomItemDisplayEvent.MOVE, _self));		}		    }}