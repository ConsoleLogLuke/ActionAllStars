package com.sdg.display.render{	import com.sdg.collections.QuickList;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.geom.Matrix;	import flash.geom.Point;		/**	 * The RenderLayer class manages a list of RenderObjects.	 */	public class RenderLayer	{		public var id:Object;				protected var renderList:QuickList = new QuickList();		protected var sortFlag:Boolean;				protected var w:Number;		protected var h:Number;		protected var mtx:Matrix;		protected var invMtx:Matrix;				private var _container:DisplayObjectContainer;		private var _solid:Boolean;				public function get numItems():uint		{			return renderList.length;		}				public function get x():Number		{			return mtx.tx;		}				public function set x(value:Number):void		{			mtx.tx = value;		}				public function get y():Number		{			return mtx.ty;		}				public function set y(value:Number):void		{			mtx.ty = value;		}				public function get width():Number		{			return w;		}				public function get height():Number		{			return h;		}				/**		 * The transform for the layer and its child display elements.		 */		public function get matrix():Matrix		{			return mtx.clone();		}				public function get solid():Boolean		{			return _solid;		}				public function set solid(value:Boolean):void		{			_solid = value;		}				public function set matrix(value:Matrix):void		{			mtx = (value) ? value : new Matrix();						invMtx = mtx.clone();			invMtx.invert();		}				/**		 * Constructor. 		 * 		 * @param width The width of the layer.		 * @param height The height of the layer.		 * @param matrix The transform for the layer and its child display elements.		 */		public function RenderLayer(width:Number = 0, height:Number = 0, matrix:Matrix = null, solid:Boolean = false)		{			w = width;			h = height;			this.matrix = matrix;			_solid = solid;		}				/**		 * Adds a RenderObject to the layer.		 *		 * @param item The RenderObject to add.		 */		public function addItem(item:RenderObject):void		{			// Remove item from previous parent if it exists.			if (item.parent) item.parent.removeItem(item);			item.parent = this;						var rdata:RenderData = item.data;						// Add RenderData to renderList.			renderList.push(rdata);						// Set render flag to true.			rdata.flags |= RenderData.RENDER_FLAG;						// Add display to container.			_container.addChild(rdata.display);						// Set the sort flag to true so that the items are			// sorted on the next update() call.			sortFlag = true;		}				/**		 * Returns whether the list contains the specified item.		 *		 * @param item The RenderObject to check.		 */		public function contains(item:RenderObject):Boolean		{			return item.parent == this;		}				/**		 * Returns whether the specified display is contained in this layer.		 * 		 * @param display The DisplayObject to check.		 */		public function containsDisplay(display:DisplayObject):Boolean		{			for each (var rdata:RenderData in renderList)			{				if (rdata.display == display) return true;			}						return false;		}				/**		 * Removes the specified RenderObject.		 *		 * @param item The RenderObject to remove.		 */		public function removeItem(item:RenderObject):void		{			if (renderList.removeValue(item.data) > -1)			{				// Remove display from container.				if (_container) _container.removeChild(item.display);			}		}				/**		 * Removes all RenderObjects.		 */		public function removeAll():void		{			if (_container)			{				for each (var rdata:RenderData in renderList)					_container.removeChild(rdata.display);			}						renderList.length = 0;		}				/**		 * Updates each item and sorts them based on the depth property.		 * 		 * @param baseIndex The base child index for the DisplayObjects contained in the layer.		 */		public function update(baseIndex:int):void		{			// Render.			render();						// Sort the renderList if sortFlag is true.			if (sortFlag)			{				// Sort numerically by depth.				sortRenderList();								if (_container)				{					// Sort each display, offset by the baseIndex.					var display:DisplayObject;					var i:int = renderList.length;					while (--i > -1)					{						display = renderList[i].display;						if(_container.getChildIndex(display) != i + baseIndex)						{							_container.setChildIndex(display, i + baseIndex);						}						// setChildIndex forces on invalidate. Adding a check prevents us from redrawing every frame.						// -Molly						//_container.setChildIndex(display, i + baseIndex);					}				}								sortFlag = false;			}		}				public function render():void		{		}				public function containsLocal(x:Number, y:Number):Boolean		{			if (x < 0) return false;			if (y < 0) return false;			if (x > w) return false;			if (y > h) return false;						return true;		}				public function containsGlobal(x:Number, y:Number):Boolean		{			var p:Point = globalToLocal(x, y);						if (p.x < 0) return false;			if (p.y < 0) return false;			if (p.x > w) return false;			if (p.y > h) return false;						return true;		}				public function localToGlobal(x:Number, y:Number):Point		{			return new Point(mtx.a * x + mtx.c * y + mtx.tx,  mtx.d * x + mtx.b * y + mtx.ty);		}				public function globalToLocal(x:Number, y:Number):Point		{			return new Point(invMtx.a * x + invMtx.c * y + invMtx.tx,  invMtx.b * x + invMtx.d * y + invMtx.ty);		}				internal function setContainer(container:DisplayObjectContainer):void		{			var rdata:RenderData;						if (_container)			{				for each (rdata in renderList)					_container.removeChild(rdata.display);			}						_container = container;						if (_container)			{				for each (rdata in renderList)					_container.addChild(rdata.display);									sortFlag = true;			}		}				protected function sortRenderList():void		{			// first set the depthAndIndex property of our RenderData objects			for (var i:int = 0; i < this.renderList.length; i++)			{				var rData:RenderData = renderList[i];				rData.depthAndIndex = rData.depth + i;							}						// now sort			this.renderList.sortOn("depthAndIndex", Array.NUMERIC);					}				private function traceDepth():void		{			for each(var rData:RenderData in renderList)				trace("depth: " + rData.depth + " depthi: " + rData.depthAndIndex);				 		}				public function get visible():Boolean		{			return _container.visible;		}		public function set visible(value:Boolean):void		{			_container.visible = value;		}	}}